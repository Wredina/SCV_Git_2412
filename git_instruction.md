![logo_git](800px-Git-logo.svg.png)
# Работа с гит
### работа с гит
## 1. проверка наличия установленного гит
В терминале выполнить команду `git version`
```JS
while (n > 0)
{
  n++;
}
```
Если гит установлен, появится сообщение о верисии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с сайта 
https://habr.com/ru/post/541258/.
Устанавливаем с настройками по умолчанию

# 3. Настройка Git

При первом использовании Git необходимо представиться. Для этого нужно ввести в терминале 2 команды:
```
git config --global user.name "name"
git config --global user.email "email"
```
## 4. Инициализация репозитория

Для локальной инициализации репозитория, нужно создать папку и в терминале ввести команду 
```
git init
```
Тогда все изменения в папке будут отслеживаться.

* что бы проверить состояние репозитория в данный момент, вводится команда:
```
git status
````

# 5. Работа с файлами

Создаём любой файл в нашей папке, например `git_instruction.md` и проверяем статус нашего репозитория через команду
```
git status
```
В консоле должно показать:
```js
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   git_instruction.md

no changes added to commit (use "git add" and/or "git commit -a")
```
Если присмотреться к выведенному сообщению, то можно увидеть, что:
1. вы находитеть на ветке **master** - это ваша основная ветка, в которой вы работаете.
```
On branch master
```
2. Есть изменения в репозитории, которые ещё не зафиксированны
```
Changes not staged for commit:
```
3. Подсказки Git, какими командами можно зафиксировать или отменить изменения в репозитории.
```js
(use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
  ```
4. В каких файлах были изменения. В данном случае, мы добавили файл, но так же если в нём будут происходить какие-либо изменения, он будет так же выводиться
```js
modified:   git_instruction.md
```
5. ну и что бы сохранить данное изменение, Git предлагает *закоммитить* изменения, т.е. зафиксировать их при помощи следующих комманд:
```js
no changes added to commit (use "git add" and/or "git commit -a")
```

## 6 Фиксация и проверка изменений
### **`1.`** Для того, что бы зафиксировать изменения в нашем файле, введём команду, которую предлагает Git и укажем ему, какой файл нужно поставить в очередь для фиксации
```
git add git_instruction.md
```
* убедитесь, что вы нигде не опечатались и ввели разрешение файла. Иначе команда не сработает.

### **`2.`** Что бы убедиться, что вы всё сделали правильно, нужно ввести команду
```
git status
```
Которая покажет, в каком состоянии находится наш файл.
```js
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   git_instruction.md
```
Здесь Git говорит, что изменения готовы для фиксации. Либо если вы хотите вернуть файл в изначальное состояние, используй команды
```
(use "git restore --staged <file>..." to unstage)
```
Но нам нужно их всё же зафиксировать.

### **`3.`** Что бы зафиксировать изменения в нашем файле, нужно его **закоммитить** 
Для этого используется команда, после которой мы оставляем в кавычках комментарий о том, что изменилось.
```
git commit -m "added homework"
```
После этого терминал должен вывести сообщение об успешно зафиксированном (закоммиченом) файле.

```
[master 4b38285] added homework
 1 file changed, 80 insertions(+), 1 deletion(-)
 ```
 В этом сообщении `Git` говорит, что в мастере, под номером 4b38285 хранится коммит под названием added homework.
 Что один файл он добавил, у меня ещё, что 80 добавлений в него и 1 удаление. Но это потому что я в нём печатаю.

### **`4.`** Просмотр изменений в нашем файле
Что бы увидеть, какие именно были внесены изменения в файл, нужно ввести команду
```
git diff
```
Вы увидите сообщение, что у вас добавился файл, ну а у меня вот это:

```js
diff --git a/git_instruction.md b/git_instruction.md
index b44ddcb..66080f0 100644
--- a/git_instruction.md
+++ b/git_instruction.md
@@ -100,6 +100,15 @@ Changes to be committed:
 Но нам нужно их всё же зафиксировать.

 3. Что бы зафиксировать изменения в нашем файле, нужно его **закоммитить**
-Для этого используется команда, после которой мы оставляем комментарий о том, что изменилось.
+Для этого используется команда, после которой мы оставляем в кавычках комментарий о том, что изменилось.
 
+git commit -m "added homework"

+После этого терминал должен вывести сообщение об успешно зафиксированном (закоммиченом) файле.
+
+```
+[master 4b38285] added homework
+ 1 file changed, 80 insertions(+), 1 deletion(-)
+ ```
+ В этом сообщении `Git` говорит, что в мастере, под номером 4b38285 хранится коммит под названием added homework.
+ Что один файл он добавил, 
\ No newline at end of file

```
Минусами добавлено то, что было изначально и плюсами то, как оно в последствии изменилось и что вобавилось ещё.
Т.е. я из в предложение добавила слово, он вывел под минусом то, как оно выглядело изначально и под плюсом показывает, какие изменения были в него внесены.

## 7. Откат к предыдущей версии и возвращение обратно.
Git никогда ничего не удаляет. Любое закоммиченное действие хранится в его памяти и т.к. для начала работы, надо представиться, то и при каких либо изменениях, Git так же будет знать, кто их сделал.
Удалить можно, но это потом.
Сейчас, к примеру, мы в файле написали некоторый текст, воспользовались командами

`git status` - что бы посмотреть состояние  репозитория, увидели, что там в очереди нафиксацию наш файл

`git add git_instruction.md` - для добавления файла в очередь для коммита

`git commit -m "chenge homework"` - добавили коммит для фиксации проделанной работы

и теперь используем команду
```
git log
```
Она вызывает список всех сделанных коммитов. Самый первый внизу, самый свежий вверху
```
commit bda1672ddbe2d0aa2fd73f4776e1fadf6bd42a58 (HEAD -> master)
Author: Sofiya <n.d.dead@mail.ru>
Date:   Fri Dec 16 16:12:33 2022 +0300

    chenge homework

commit 4b38285846c417b10f13196b117e07988aab6f20
Author: Sofiya <n.d.dead@mail.ru>
Date:   Fri Dec 16 15:29:00 2022 +0300

    added homework
```

В терминале мы видим автора каждого коммита, дату и время сделанного коммита,
так же сообщение коммита, что было сделано и самое главное, это номер коммита, благодаря которому можно перемещаться между коммитами. 

Например, нам нужно вернуться на предыдущий коммит.
Для этого копируем первые 5 (от 5-ти чисел) номера коммита, в терминале прописываем комманду после которой ставим номер коммита, к которому хотим перейти.
```
git checkout 4b382
```
и перемещаемся к коммиту added homework и все файлы вернуться в то состояние, в котором были в момент создания того коммита, а все последующие изменения которые были сделаны - исчезнут.

Что бы вернуться обратно, в текущую версию, вводим команду
```
git checkout master
```
и всё что было на момент создания последнего коммита - вернётся.

# 8. Упрощение комманд
* `git add` и `git commit` можно объединить в однук оманду `git commit -a -m "comment"` но нужно учесть, что это новая комманда, сохраняет изменения абсолютно всех файлов в репозитории.
На случай неправильно записанного коммита, название можно поменять при помощи комманды `git commit --amend -am "переименновываем"`
* `git log` имеет ещё несколько форм: `git log --oneline` - выводит все коммиты в одну строчку - очень удобно; `git --oneline -1` выводит последний коммит.
* `git help` - показывает все команды, которые есть в гите. А так же, если хотите посмотреть какие ещё формы может иметь кака либо комманда `git -h add` - перекинет на сайт с данным команды, либо что бы вывести прямо в терминале `git add -h`


# 9. Работа с ветками
### `1.` Создание ветки и переход между ними
Ветки нужны как для дробление одной большой задачи на подзадачи, так и для самостоятельной отработки нескольких вариантов развития основной работы. 
Т.е. мы работаем над проектом и вдруг у нас возникает идея, как можно её ещё по другому отработать, но не уверены в конечности результата - тогда можно создать отдельную ветку и проработать там идею и если во время проработки этой идеи возникнет ещё интересные мылси - можно создавать ещё ветки. И если эти планы сработают, то можно всю работу влить в основную ветку и продолжить работать уже с проверенной информацией.
* для создания ветки используется команда
```
git branch название_ветки
```
* для перехода в новую ветку
```
git checkout название_ветки
```
Т.е. при создании новой ветки, мы в неё автоматически не перемещаемся, а остаёмся на той же, на которой работали.
так же, можно вывести список всех веток и посмотреть, на какой именно мы находимся.
* для вывода списка всех веток
```
git branch
```
получим такое поле:
```
  instruction_work
* master
  task
  work_ignore
```
Звёздочка на против ветки указывает, где именно мы сейчас находимся.

---
`Коротка команда:`
* что бы создать и сразу перейти на ветку
```
git checkout -b название_ветки
```
---

### `2.` Переименовывание ветки
Если Вам необходимо переименовать ветку, то необходимо в неё войти и воспользоваться командой
* переименовывание ветки, в которой находишься
```
git branch -M название_ветки
```

## 10. Слияние веток
Наступает момент, когда информацию, которая находится в других ветках, нужно переместить в основную ветку - это называется слияние веток.
* Что бы слить добавить информацию из `Ветки2` в `Ветку1`, нужно перейти в `Ветку1` при помощи `git checkout Ветка1` и задать команду
```
git merge Ветка2
```
Тогда вся информация из `Ветки2` переместится в `Ветку1`
Т.е. что бы добвить в ветку информацию из другой ветки, вы должны в ней находиться и сказать гиту из какой ветки Вы хотите влить сюда информацию.

## 11. Разрешение конфликтов
Если при работе в разных ветках над одним проектом, вы на одних и тех же строчках закоммитите информацию и попытаетесь их слить, то при слиянии этих веток произойдёт конфликт. VS выведет места, в которых произошёл `конфликт`, а так же предложит варианты по их решению: 
* принять изменеия одной из веток
* принять оба изменения и в ручную отредактировать
* сравнить изменения
Т.е. гит не может самостоятельно в одно и то же мето записать сразу 2 изменения.
Выбираете нужный вариант и гит его сохранит.

## 12. Удаление веток
Часто после слияния веток, они больше нам не нужны, поэтому их удаляют.
* что бы удалить ветку
```
git branch -d название_ветки
```
Но это сработает, если все изменения в ветке уже слиты с основной. Но что, если, работая в этой ветки, Вы поняли, что информация на ней не несёт никакой ценности и сливать с основной нет смысла - можно удалить.
* принудительное удаление ветки
```
git branch -D название_ветки
```

## 13. Игнорирование файлов
Игнорирование файлов нужно, если мы не хотим, что бы гит их отслеживал. Как правило, это относится к каким-то большим файлам или картинкам, с которыми мы не работаем.
Что бы задать гиту список игнорируемых файлов, нам нужно в папке, в которой работаем, создать файл `.gitignore`
Через VS code открываем этот файл и создаём там списочек игнорируемых файлов вместе с разширением, например: `котик.png`
Если у нас много файлов одного разширения, например, png, то можно создать следующую запись:
```
*.png
```
звёздочка указывает, что все файлы данного разрешения будут включены в этот список.
# 14 Работа с удалённым репозиторием
1. Нужно зарегестрироваться на сайте GitHub. 
2. Нужно создать свой репозиторий на сайте при помощи кнопки `New repo` и пройти по инструкции.
3. GitHub сам предложит варианты, как можно привязать Ваш локальный репозиторий, с удалённым:
```
echo "# home_work" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin ССЫЛКА
git push -u origin main
```
или
```
git remote add origin ССЫЛКА
git branch -M main
git push -u origin main
```
Тут указано, что нужно обязательно, что бы наш локальный репозиторий был инициирован, там уже должен быть файл и коммит. Так же нужно переименовать нашу ветку `master` в ветку `main` и загрузить её на удалённый репозиторий, для отслеживания.

## 15. Загрузка и выгрузка с удалённого репозитория
Вот вы подружили свой удалённый репозиторий со своим локальным, так как же работать дальше? 

`1.` В нашем локальном репозитории можно создавать или дорабатываеть старые файлы, сохранять и делать коммиты, в общем всё, что делали ранее и что бы показать свою работу, для начала нужно загрузить это всё на удалённый.
* выгрузка из локально репозитория в удалённый
```
git push
```
Команда позволит отправить все изменения на данной ветке в репозиторий.

`2.` На самом сайте так же можно изменять свой файл и делать на нём коммиты. И после этих изменений, было бы не плохо выгружать это к себе на локальный.
* выгрузка обновлений на текущей ветке из удалённого репозитория
```
git pull
```
Но при загрузки данных к себе в локальный репозиторий, произойдёт слияние веток.
Т.е. если на удалённом репо и на локальном, в одной и той-же строчке будет разная информация, возникнет конфликт, который VS code предложит решить так же, как и до этого, когда конфликтовали разные ветки.

`3.` Так же когда закачиваешь всю информацию на удалённый репозиторий, с использованием нескольких веток, которых нет в удалённом репозитории, GitHub даст `Pull Request` - запрос на на интеграцию изменений из одной ветки в другую. И он используется для описания изменений и комментариев между участниками.
Т.е. он записывает некоторые изменения, которые вы внесли.

## Pull request
Часто приходится работать с другими авторами различных проектов, помогать им и т.д.
Для этого нам нужен клон их репозитория
1.  что бы склонировать чужой удалённый репозиторий в свой:
на странице чужого репозитория есть кнопка `Fork` - она копирует нужный репозиторий в наш.

2. Этот репозиторий нам нужно вытянуть к себе
```
git clone ссылка
```
эта команда позволяет стянуть к себе на локальный репозитори чужую работу.

Так принято, что обычно, для работы с чужим кодом, создаётся новая ветка, и уже на ней начинается разработка.

После завершения разработки, нам необходимо загрузить все изменения обратно и через `pull requst` оставить сообщение автору, т.к. ему упадёт запрос на просмотр изменений.

При загрузки на удалённый репозиторий, т.к. мы работали на отдельной ветке, эту ветку тоже нужно загрузть
```
git push -u origin название_ветки
```
либо, второй вариант, предлагаемый гитом
```
git push --set-upstream origin название_ветки
```